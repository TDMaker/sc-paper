# 以太坊智能合约 + 远程数据完整性审计
一个将远程数据完整性审计结合于以太坊智能合约场景的方案。

直观思想是：完整性验证的功能基于 PBC，各方的交互部分放在智能合约上进行。

灵感与贡献：最初的远程数据完整性审计是只有数据拥有者（DO）和服务提供商（SP）两方的，后来 DO 由于计算能力或是时间精力的原因，或是一旦审计有问题，DO 和 SP 这个双参与方系统无法讲出问题真相，所以后面的审计任务会外包给一个第三方审计者 TPA，但这个系统可行的假设是建立在 TPA 的可信性上，但在实际中这个假设过于强了，TPA 极有可能与 SP 勾结以达到欺骗 DO 获取利益的目的。后来就引入了多 TPA 共同审计，根据他们的多个结果共同决定最终的审计结果。但这就会审计到多方计算中的投票问题，更深一点就是成员问题——谁可以成为成员？谁有投票权？投票的权重如何？如果系统提供了准入门槛，那么准入门槛的维护机制必然会及其复杂、同时又很难做到公平，最后很容易就发展成了集中制和中心化，于是就又退化成了最初的一个 TPA 的状态。如果系统不提供准入门槛，最直接能想到的就是会遭到 “女巫攻击”，即一方势力生成大量账号（这几乎没有成本），然后共同参与，即使有方案引入了 “声誉” 的概念，依然不能很好解决问题。

> 如果方案中声誉可以作为投票的权重，那在系统的 “冷启动” 阶段一方势力就可以正常参与，甚至通过自己提交审计任务快速提高自己账号群的整体权重，在中后期仍可以在系统中一家独大。

解决多方计算问题的一个最著名的方案就是区块链了。区块链的目前共识机制是建立在工作量证明上的，即认为系统中诚实的人掌握大部分的计算力。但与区块链场景不同，区块链是闭环系统，审计系统是非闭环的（==此处需解释==）。在我们设计的方案中

1. 可以防止 Auditor 和 SP 勾结。在申请审计的所有审计者中，只有有一个审计者没有串通其他审计者和 SP，勾结攻击就不会奏效。
2. 可以有效降低 SP 计算量。如果 SP 存储了很多用户的很多文件，持续的大量审计也会给 SP 带来巨大开销，这甚至是一种 DDOS 或是 CC 攻击，沉重的验证任务计算量有可能会造成 SP 正常业务的质量降级。我们证明了在能达到相同审计水平的情况下，可以使 SP 的计算量下降（==证明==）。
3. 两次使用两阶段提交，可以防止不作为的审计者在审计时不计算，而仅仅抄袭其他审计者的答案。
4. 如果审计者们的审计结果不一致，最后会由数据拥有者进行仲裁，这种情况看似与仅有 DO 和 SP 参与的双方系统类似，但实则完全不同，首先这种情况应该会很罕见，引发仲裁势必会令不诚实的审计者失掉押金，说谎行为对审计者来讲是毫无意义的，因为说谎行为一定会被发现；其次，引发仲裁可以使 DO 在审计任务中获利，虽然 DO 审计数据必然要交审计费，但仲裁行为可以使 DO 参与到对不诚实的审计者押金扣款的分钱中，这对 DO 来讲是有极大动力的。
5. 基于区块链智能合约的审计，审计任务的每一步得到数据都会持久化到区块链中，由于区块链的不可篡改性，如果审计过程中出现 DO 与某审计者串通非法获得其他诚实审计者押金的行为，事后诚实的参与者一定可以提取到存储在区块链上的审计信息，可以去线下司法机关提请进一步的法律过程。其次，每个 DO 在发布审计任务时都会将自己的 ID (即地址)、要审计的文件信息等发给在监听审计任务的审计者们，审计者们可以根据收到的审计请求中的信息来决定是否要申请这个审计任务。

## 目录结构及文件说明

- `config.js`：存储系统中 chair person、data owner、service provider 和 auditor 四个参与方的私钥。此处为方便将各方私钥存于一处，实际部署时，各方应只存储自己的私钥。
- `utils`：C 语言工具函数，用于完整性审计的。
  - `randys.c`：读写文件、串数转换、生成伪随机数等。
  - `sha256.c`：计算一个 buf 的 sha256 哈希。
- `swap_zone`：存储外包文件的信息，以原始文件名命名，里面包含原文件的分块信息，即分块数目即每个块的大小。
- `storage_provider`：Service Provider 相关代码。
  - `tag_verify.c`：当 DO 将外包文件分块并生成 HVT 后，会将文件块和 HVT 发给 SP，此文件将文件块和 HVT 联合计算，验证文件块是否是处。
  - `proof_gen.c`：在审计阶段，收到挑战之后，此文件根据挑战生成完整性证明。
  - `makefile`：编译 C 文件，清除临时文件。
  - `data`：为每个审计任务存储收到和生成的数据。
    - `0x0123...`
      - `mu`：自己生成的完整性证明两部分之一。
      - `sigma`：自己生成的完整性证明两部分之二。
      - `sum_r`：收到的挑战用于生成伪随机数的两颗种子之一。
      - `sum_s`：收到的挑战用于生成伪随机数的两颗种子之二。
  - `storage`：存储用户的外包数据及 HVT。
    - `blks`：文件块目录，里面的文件名如 `12345_blk_0`。
    - `sigs`：HVT 目录，与上面文件名对应 `12345_sig_0`。
  - `web-client`：与以太坊智能合约通信的部分，是连接本地 C 程序和智能合约的中间件。
    - `task-listener.js`：监听任务、处理任务。
- `smart-contracts`：以太坊智能合约源代码，编译后生成 ABI 和 Bytecode。
  - `AuditTask`：另一个合约的工厂方法产生的具体做审计任务的合约，审计过程的逻辑在这里。
  - `TaskManagement`：原始监听合约，在以太坊中监听 DO 的审计请求，然后实例化审计任务。
- `public_params`：C 部分 setup 和 sig_gen 后，存储一些公共参数。
  - `a.param`：用于初始化配对的参数，最原始参数。
  - `g`：$G_2$ 中的一个元素，在 `setup.c` 中生成。
  - `h`：$G_1$ 中的一个元素，在 `setup.c` 中生成。
  - `public.key`：$G_2$ 中的一个元素，所谓公钥，在 `setup.c` 中生成。
  - `123456...`：外包文件的文件名，里面存的是它作为 Zr 中元素的字节形式，在 `sig_gen.c` 中生成。
- `data_owner`：Data Owner 相关代码。
  - `the-sun-allso-rises.mp3`：要被外包出去的原文件，是一首好听的歌。
  - `sig_gen.c`：生成外包文件名、文件块、分块信息和 HVT。
  - `setup.c`：生成 `g`, `h`, `secret.key` 和 `public.key`。
  - `secret.key`：setup 中产生的私钥。
  - `makefile`：编译 C 文件，清楚中间文件，清楚相关公共参数文件，清楚外包的文件块和 HVT。
  - `arbitrate.c`：审计者们结果不一致时，由这个文件来实现仲裁功能。
  - `data`：为每个审计任务仲裁收到和生成的数据。
    - `0x0123...`
      - `mu`：自己生成的完整性证明两部分之一。
      - `sigma`：自己生成的完整性证明两部分之二。
      - `sum_r`：收到的挑战用于生成伪随机数的两颗种子之一。
      - `sum_s`：收到的挑战用于生成伪随机数的两颗种子之二。
      - `right_equation`：计算得到的双线性配对对比等式的右半部分，为防智能合约上溢已做截断处理。
      - `result`：仲裁结果。
  - `web-client`：与以太坊智能合约通信的部分，是连接本地 C 程序和智能合约的中间件。
    - `index.js`：`enroll` 参数是注册文件，`request` 参数是审计目标文件。
- `chairperson`：智能合约中 Chair person 相关代码。
  - `manage-address.txt`：当下在以太坊上部署好的审计任务管理合约的地址。
  - `init.js`：启动后重新部署管理合约，完成后将地址更新在 `manage-address.txt`中，实际场景中可能是需要通过网络公布给相关的参与方。
  - `bc-manage.json`：manage 合约的 Bytecode。
  - `abi-manage.json`：manage 合约的 ABI。
  - `abi-audit.json`：审计合约的 ABI。
  - `instance-address`：每一个文件以部署的实例化的管理合约地址命名，文件名中每一行是该管理合约下实例化的审计任务的合约地址。
- `auditor`：审计者相关的代码。
  - `proof_verify.c`：SP 提交给智能合约完整性证明后，验证是否正确。
  - `challenge.c`：生成挑战。
  - `web-client`：与以太坊智能合约通信的部分，是连接本地 C 程序和智能合约的中间件。
  - `data`：为每个审计任务存储收到和生成的数据。
    - `0x0123...`
      - `mu`：收到的完整性证明两部分之一。
      - `sigma`：收到的完整性证明两部分之二。
      - `sum_r`：收到的用于生成伪随机数的两颗种子之一。
      - `sum_s`：收到的用于生成伪随机数的两颗种子之二。
      - `right_equation`：计算得到的双线性配对对比等式的右半部分，为防智能合约上溢已做截断处理。
      - `result`：要提交的审计结果。
      - `r`：自己生成的随机数之一，用于挑战。
      - `s`：自己生成的随机数之二，用于挑战。
      - `rs.sha`：在提交 `r` 和 `s` 之前提交的 `r+s` 和的哈希，两阶段提交防止抄袭。
      - `rightr.sha`：在提交 `right_equation` 和 `result` 之前提交的 `right_equation+result+r` 和的哈希，两阶段提交防止抄袭。

## 使用流程及方法

### C 部分

1. `cd path/to/data_owner`
   1. `make all`
   2. `./setup.out`
   3. `./sig_gen.out`
2. `cd path/to/storage_provider`
   1. `make all`
   2. `./tag_verify.out`
3. `cd path/to/auditor`
   1. `make all`
4. `cd path/to/auditor2`
   1. `make all`

### 以太坊部分

1. `path/to/config.js`，更新各方私钥（如果需要的话）。
2. 更新以下文件（如果需要的话）：
   - `path/to/chairperson/abi-manage.json`：
   - `path/to/chairperson/abi-audit.json`：
   - `path/to/chairperson/bc-manage.json`
3. `cd path/to/chairperson`，`node init.js`：
   - 此时 Chairperson 会在区块链上部署并监听管理合约，然后将合约地址写入 `path/to/chairperson/manage-address.txt`。
4. `cd path/to/storage_provider/web-client`，`node task-listener.js` 开启监听。
5. `cd path/to/auditor/web-client`，`node task-listener.js` 开启监听。
6. `cd path/to/auditor2/web-client`，`node task-listener.js` 开启监听。
7. DO 找到 `path/to/public_params` 或 `path/to/swap_zone` 中新生成的文件的名字，填入 `path/to/data_owner/web-client/index.js` 中的 `fileName` 变量，找到此文件所外包给的存储服务商的地址，填入 `spAddress` 变量。
8. `cd path/to/data_owner/web-client`，`node index.js enroll` 向管理合约注册文件。
9. `node index.js request` 向管理合约提交审计申请，同时开启监听。
10. 提交审计申请后，经过一些验证，通过后，管理合约的审计合约工厂会产生一个对该文件的审计合约实例，然后将该实例的地址事件到所有监听该事件的监听者。
11. Storage provider 收到后，根据通知信息判断是否与自己有关，如果无关则不予理会，否则要开启监听该审计合约的相关事件。
12. Data owner 收到后，根据通知判断是否是自己的文件（因为可能系统中同时有多个审计任务，只监听与己有关的）。
13. 众 Auditors 收到后，根据通知中的审计信息，判断自己是否要接受该审计任务。
14. Chairperson 收到后，开始调度这个审计合约的实例，整个审计过程的进行就是有 Chairperson 驱动的。这==里应该有个自动机表示这个有点负责的状态转移过程==。
15. 之后的过程就是自动的，最终的状态可能是审计者们得出了共同的结论，或者没有得出共同结论后由 Data owner 仲裁得到最终的完整性审计的结果。

